# Game workflow

This document describes the full runtime sequence of Midori AI AutoFighter and how player progress is persisted between runs.

## Package layout
Source code lives under the backend:

- `autofighter` – core game logic
- `plugins` – player and foe extensions
- `rooms` – battle, rest, shop, and other endpoints
- `gacha` – pull logic and results presentation
- `saves` – load and save utilities

## Startup
- `PluginLoader` scans the `plugins/` directory to register available classes.
- `RoomManager` coordinates transitions between battle, shop, rest, and other rooms for each run.
- The Quart app exposes endpoints that the web frontend calls to drive gameplay.
- `MapGenerator` creates 45-room floors seeded per run, guaranteeing at least two shops and two rest rooms. Pressure Level adds extra rooms and boss encounters, and chat rooms may appear after battle nodes without increasing the room count.
- A drifting color cloud fills the background while the camera stays fixed. The main menu presents an Arknights-style 2×3 grid of large Lucide icons with text labels for *New Run*, *Load Run*, *Edit Player*, *Options*, *Give Feedback*, and *Quit*. Icons show tooltips on hover, the focused option is highlighted for keyboard navigation, and the **Give Feedback** button launches a pre-filled GitHub issue in the user's browser. See [main-menu instructions](../instructions/main-menu.md) for layout details.
- A Player Creator offers body style, hair style, hair color, and accessory options while distributing 100 stat points as +1% increments. Sliders clamp allocations so totals cannot exceed the available points. Each selector and stat slider now includes a label with helper text shown on hover or keyboard focus. Spending 100 of each damage type's 4★ upgrade items adds one extra point, and remaining inventory is saved when confirming.
- Confirmed choices are saved to `player.json` and loaded for new runs. A Load Run menu lists available save files, and an Options screen shows Lucide icons with labels and tooltips for SFX volume, Music volume, Stat Screen refresh rate, and framerate and autocraft controls.
- A Stat Screen scene displays grouped stats (core, offense, defense, vitality, advanced) and status lists for passives, DoTs, HoTs, damage types, and relic stacks, refreshing every few frames.
- Damage-over-time and healing-over-time effects are handled by an `EffectManager` that records active effect names on `Stats`, supports Bleed, Celestial Atrophy, Abyssal Corruption that spreads on death, Blazing Torment with extra ticks via an `on_action` hook, and Impact Echo repeating half the last hit.
- Selecting *New Run* starts a Battle Room that exchanges event-bus-driven turns with stat-based accuracy, scaled foes, floating damage numbers, attack effects, status icons, and an overtime warning after 100 turns (500 for floor bosses) that grants an Enraged buff. The loop pauses briefly between actions so the async server stays responsive.
- Active runs persist across page reloads. The frontend caches `runId` and the next room in `localStorage`, verifies the ID via `/map/<run_id>` on startup, and resumes the current room if valid; invalid IDs are cleared.
 - Rest Rooms grant access to gacha pulls and party swapping without advancing the run, and at least two must appear on each floor via `RestRoom.should_spawn`.
 - Shop Rooms sell upgrade items and cards with gold pricing, star ratings, floor-based inventory scaling, and reroll costs. Purchases add items to inventory, and class-level tracking ensures at least two appear per floor.
 - Event Rooms present text prompts with selectable options that deterministically modify stats or inventory using seeded randomness. They may occur after battles without consuming the floor's room count.
 - Chat Rooms let players send a single message to an LLM character. Usage is limited to six chats per floor, and rooms should not spawn once the limit is reached.

## Wave preparation
- Before a wave begins, fighters level up and their updated state is written back to `lives/`.
- Foes are generated by combining adjectives and themed names, then modified by `foe_passive_builder.py`.

## Battle loop
- Waves play out automatically while fighters and foes exchange attacks.
- During combat, summaries append to `logs/<name>.txt`.
- When a fighter's HP reaches zero, `save_past_life` archives their data to `past_lives/<uuid>.pastlife` and deletes the active save.

## Run termination
- The game ends when all fighters have been defeated.
- The engine writes each fighter's final state to `lives/<name>.dat` (e.g., `lives/Ally.dat`) and exits—no manual action is required.
- On the next launch, surviving fighters or new ones resume from the data in `lives/`.
